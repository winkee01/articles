## TinyGo
TinyGo 并非另一门编程语言。它只是 Go 语言的编译器。关键区别在于 TinyGo 编译器创建的二进制文件更小，主要用于嵌入式系统和 WASM。而 Go 编译器则是用于编译完整的服务器端应用程序和通用程序。

TinyGo 使用 LLVM 作为其后端，与 Go 编译器相比，生成的二进制文件更小。例如，一个打印“Hello World”的非常简单的代码，用 Go 编译后可能得到大约 800 KB 的二进制文件，而 TinyGo 可以将其减少到大约 10 KB，其主要通过去除不必要的符号来实现的。

TinyGo 的特性与限制
Ggo
虽然 TinyGo 集成了 Clang 编译器来解析import "C" 块，但 Cgo 的一些功能仍然不受支持或可能略有不同。例如，#cgo 语句仅部分支持。

反射
Go 有很多包，尤其是在标准库中，依赖于反射来工作。reflect 包已在 TinyGo 中重新实现，大部分功能正常，但某些部分尚未完全支持。

Maps
映射通常运行良好，但可能要比预期的要慢。这有几个原因，其中之一是某些类型（如结构体）可能内部使用反射而不是使用专门的哈希/比较函数进行比较。

标准库
由于上述缺失的部分，以及标准库的某些部分依赖于特定的编译器/运行时，许多包尚未编译。请在此处查看已经编译的包的列表[1]（但请注意，“编译”并不意味着工作完全正常）。

垃圾回收
垃圾回收通常工作良好，但在非常小的芯片（AVR）和 WebAssembly 上可能效果不佳。它也比常规的 Go 垃圾回收器慢得多。谨慎的设计可以避免在主循环中分配内存，这可以大大降低性能。可以使用选项-print-allocs=. 来编译以找出分配发生的位置和原因。更多信息，请参阅堆分配[2]。

了解更多关于语言支持的信息，请查看此处[3]。

全局变量
TinyGo 在编译期间计算全局变量，这可以优化启动时间并减少内存使用，而 Go 编译器对全局变量的处理方式不同。这是出于几个重要原因的重要优化：

启动时间缩短了。这很好，但不是如此设计的主要原因。
初始化全局变量，通过从闪存复制初始数据到 RAM，所需闪存空间更少，因为只需存储实际数据，而不是初始化这些全局变量的所有指令。
数据通常可以在启动时静态分配，而不是动态分配。
死亡的全局变量被 LLVM 简单地优化掉。
全局常量对于常量传播和因此对于死代码消除（例如依赖于全局变量的if ）是有用的。
总结
总的来说，TinyGo 通过在受限环境中运行 Go 语言的能力，牺牲了一些标准 Go 编译器中的特性和性能优化，从而扩展了 Go 的功能。它特别适用于针对物联网设备和 WebAssembly 应用程序的开发者，在这些场景中，二进制文件大小和资源效率至关重要。

参考资料
[1]
列表:https://tinygo.org/docs/reference/lang-support/stdlib/

[2]
堆分配:https://tinygo.org/docs/concepts/compiler-internals/heap-allocation/

[3]
此处:https://tinygo.org/docs/reference/lang-support/